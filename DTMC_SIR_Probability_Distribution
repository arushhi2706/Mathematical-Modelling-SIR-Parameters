import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Parameters
N = 100
beta = 1.0
gamma = 0.5
delta_t = 0.01
T = 30
steps = int(T / delta_t)
initial_state = (98, 2)
num_simulations = 1000

# Function: Simulate one stochastic SIR path
def simulate_stochastic_sir():
    S, I = [initial_state[0]], [initial_state[1]]
    for t in range(steps):
        s, i = S[-1], I[-1]
        probs = np.array([
            beta * s * i / N * delta_t,      
            gamma * i * delta_t,             
            1 - (beta * s * i / N + gamma * i) * delta_t  
        ])
        probs = np.clip(probs, 0, 1)
        probs = probs / np.sum(probs)

        transition = np.random.choice(['infection', 'recovery', 'none'], p=probs)
        if transition == 'infection' and s > 0:
            s -= 1
            i += 1
        elif transition == 'recovery' and i > 0:
            i -= 1
        S.append(s)
        I.append(i)
    return I  # Return only infectives over time

# --- Build probability matrix: time step x infective count ---
infective_probs = np.zeros((steps + 1, N + 1))  # Rows: time, Cols: infective count

for _ in range(num_simulations):
    I_path = simulate_stochastic_sir()
    for t, i in enumerate(I_path):
        infective_probs[t, i] += 1

infective_probs /= num_simulations  # Normalize to get probability

# --- Create 3D plot ---
fig = plt.figure(figsize=(14, 8))
ax = fig.add_subplot(111, projection='3d')

T_grid, I_grid = np.meshgrid(np.linspace(0, T, steps + 1), np.arange(N + 1))
Z = infective_probs.T  # Transpose to align shape: infectives x time

surf = ax.plot_surface(T_grid, I_grid, Z, cmap='viridis', edgecolor='none')

ax.set_xlabel('Time')
ax.set_ylabel('Number of Infectives')
ax.set_zlabel('Probability')
ax.set_title('Probability Distribution: Infectives over Time')
fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5, label='Probability')

plt.tight_layout()
plt.show()

